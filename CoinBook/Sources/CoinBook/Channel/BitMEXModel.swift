import Foundation

/// BitMEX API Channel.
/// - Type definietions are from https://github.com/BitMEX/api-connectors/blob/56edbdff0139fa85171dcd8b00b43d434d81c31c/swagger.json
/// - Swagger Swift codegen is not that great. I wrote types manually. Custom code-gen will be required for production.
///   For example, Swift code-gen for `OrderBookL2.id` generated `Double` type, but it's actually `Int64` on source Swagger spec.
///   - [Source Swagger spec](https://github.com/BitMEX/api-connectors/blob/56edbdff0139fa85171dcd8b00b43d434d81c31c/swagger.json#L5755).
///   - [Autogenerated](https://github.com/BitMEX/api-connectors/blob/master/auto-generated/swift4/SwaggerClient/Classes/Swaggers/Models/OrderBookL2.swift#L15),
///   Therefore I build a proper types from source Swagger spec.
///
extension BitMEXChannel {
    enum Topic: String, Codable {
        case orderBookL2_XBTUSD = "orderBookL2:XBTUSD"
        case orderBookL2_25_XBTUSD = "orderBookL2_25:XBTUSD"
        case trade_XBT_USD = "trade:XBTUSD"
        /// There are more, but I do not use them.
    }
    
    struct Info: Codable {
        var info: String
        var version:String
        var timestamp:String
        var docs:String
    }
    struct Subscribe: Codable {
        var subscribe: Topic
        var success: Bool
    }
    struct Table: Decodable {
        var metadata: TableMetadata
        var rows: TableRows
        init(from decoder: Decoder) throws {
            metadata = try TableMetadata(from: decoder)
            struct RowsDecoding<T:Decodable>: Decodable { var data:[T] }
            switch metadata.table {
            case "orderBookL2_25", "orderBookL2":
                rows = .orderBookL2(try RowsDecoding<OrderBookL2>(from: decoder).data)
            case "trade":
                rows = .trade(try RowsDecoding<Trade>(from: decoder).data)
            default:
                rows = .unknown
            }
        }
    }
    struct TableMetadata: Decodable {
        var table: String
        var action: Action
        enum Action: String, Codable { case partial, update, insert, delete }
        struct Ignore {}
        var keys: [String]?
        var foreignKeys: [String:String]?
        var types: [String:`Type`]?
        enum `Type`: String, Codable { case symbol, guid, timestamp, timespan, float, long, integer, boolean }
        var filter: Filter?
        struct Filter: Codable {
            var account: Double?
            var symbol: String?
        }
        var attributes: [String:String]?
    }
    enum TableRows {
        case orderBookL2([OrderBookL2])
        case trade([Trade])
        case unknown
    }
    
    /// https://github.com/BitMEX/api-connectors/blob/56edbdff0139fa85171dcd8b00b43d434d81c31c/swagger.json#L5749
    struct OrderBookL2: Codable {
        var symbol: String
        var id: Int64
        var side: String
        var size: Int64?
        var price: Double?
    }
    /// https://github.com/BitMEX/api-connectors/blob/56edbdff0139fa85171dcd8b00b43d434d81c31c/swagger.json#L6395
    struct Trade: Codable {
        var timestamp: String
        var symbol: String
        var side: String?
        var size: Int64?
        var price: Double?
        var tickDirection: String?
        var trdMatchID: String? /// GUID?
        var grossValue: Int64?
        var homeNotional: Double?
        var foreignNotional: Double?
    }
    
    enum Command: Codable {
        case subscribe(topics:[Topic])
        case unsubscribe(topics:[Topic])
    }
    enum Report: Decodable {
        case info(Info)
        case subscribe(Subscribe)
        case table(Table)
        case error(Error)
        init(from decoder: Decoder) throws {
            let c = try decoder.container(keyedBy: Field.self)
            if c.contains(.info) {
                self = .info(try Info(from: decoder))
                return
            }
            if c.contains(.subscribe) {
                self = .subscribe(try Subscribe(from: decoder))
                return
            }
            if c.contains(.table) {
                self = .table(try Table(from: decoder))
                return
            }
            if c.contains(.error) {
                self = .error(Issue.bitMEX(.serverError(try c.decode(String.self, forKey: .error))))
            }
            throw Issue.bitMEX(.badFormMessage(message:"Cannot determin message type.", codingPath: decoder.codingPath))
        }
        typealias CodingKeys = Field
        enum Field: String, CodingKey {
            case info, subscribe, error, table
        }
    }
}
