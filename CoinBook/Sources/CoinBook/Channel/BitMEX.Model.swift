import Foundation

/// BitMEX API Channel.
/// - Type definietions are from https://github.com/BitMEX/api-connectors/blob/56edbdff0139fa85171dcd8b00b43d434d81c31c/swagger.json
/// - Swagger Swift codegen is not that great. I wrote types manually. Custom code-gen will be required for production.
///   For example, Swift code-gen for `OrderBookL2.id` generated `Double` type, but it's actually `Int64` on source Swagger spec.
///   - [Source Swagger spec](https://github.com/BitMEX/api-connectors/blob/56edbdff0139fa85171dcd8b00b43d434d81c31c/swagger.json#L5755).
///   - [Autogenerated](https://github.com/BitMEX/api-connectors/blob/master/auto-generated/swift4/SwaggerClient/Classes/Swaggers/Models/OrderBookL2.swift#L15),
///   Therefore I build a proper types from source Swagger spec.
///
extension BitMEXChannel {
    enum Topic: String, Codable {
        case orderBookL2_XBTUSD = "orderBookL2:XBTUSD"
        case orderBookL2_25_XBTUSD = "orderBookL2_25:XBTUSD"
        case trade_XBT_USD = "trade:XBTUSD"
        /// There are more, but I do not use them.
    }
    
    struct Info: Codable {
        var info: String
        var version:String
        var timestamp:String
        var docs:String
    }
    struct Subscribe: Codable {
        var subscribe: Topic
        var success: Bool
    }
    enum Table: Decodable {
        case orderBookL2(metadata:TableMetadata, rows:[OrderBookL2])
        case trade(metadata:TableMetadata, rows:[Trade])
        case unknown(metadata:TableMetadata)
        init(from decoder: Decoder) throws {
            let metadata = try TableMetadata(from: decoder)
            struct RowsDecoding<T:Decodable>: Decodable { var data:[T] }
            switch metadata.table {
            case "orderBookL2_25", "orderBookL2":
                let rows = try RowsDecoding<OrderBookL2>(from: decoder).data
                self = .orderBookL2(metadata: metadata, rows: rows)
            case "trade":
                let rows = try RowsDecoding<Trade>(from: decoder).data
                self = .trade(metadata: metadata, rows: rows)
            default:
                self = .unknown(metadata: metadata)
            }
        }
    }
    struct TableMetadata: Decodable {
        /// Table name / Subscription topic.
        /// Could be "trade", "order", "instrument", etc.
        var table: String
        /// The type of the message.
        var action: Action
        enum Action: String, Codable {
            /// This is a table image, replace your data entirely.
            case partial
            /// Update a single row.
            case update
            /// Insert a new row.
            case insert
            /// Delete a row.
            case delete
        }
        
        ///
        /// The below fields define the table and are only sent on a `partial`.
        ///

        /// Attribute names that are guaranteed to be unique per object.
        /// If more than one is provided, the key is composite.
        /// Use these key names to uniquely identify rows. Key columns are guaranteed
        /// to be present on all data received.
        var keys: [String]?
        /// This lists key relationships with other tables.
        /// For example, `quote`'s foreign key is {"symbol": "instrument"}
        var foreignKeys: [String:String]?
        /// This lists the shape of the table. The possible types:
        /// "symbol" - In most languages this is equal to "string"
        /// "guid"
        /// "timestamp"
        /// "timespan"
        /// "float"
        /// "long"
        /// "integer"
        /// "boolean"
        var types: [String:`Type`]?
        enum `Type`: String, Codable { case symbol, guid, timestamp, timespan, float, long, integer, boolean }
        /// When multiple subscriptions are active to the same table, use the `filter` to correlate which datagram
        /// belongs to which subscription, as the `table` property will not contain the subscription's symbol.
        var filter: Filter?
        struct Filter: Codable {
            var account: Double?
            var symbol: String?
        }
        /// These are internal fields that indicate how responses are sorted and grouped.
        var attributes: [String:String]?
    }
    
    /// https://github.com/BitMEX/api-connectors/blob/56edbdff0139fa85171dcd8b00b43d434d81c31c/swagger.json#L5749
    struct OrderBookL2: Codable {
        var symbol: String
        var id: Int64
        var side: String
        var size: Int64?
        var price: Double?
    }
    /// https://github.com/BitMEX/api-connectors/blob/56edbdff0139fa85171dcd8b00b43d434d81c31c/swagger.json#L6395
    struct Trade: Codable {
        var timestamp: String
        var symbol: String
        var side: String?
        var size: Int64?
        var price: Double?
        var tickDirection: String?
        var trdMatchID: String? /// GUID?
        var grossValue: Int64?
        var homeNotional: Double?
        var foreignNotional: Double?
    }
    
    enum Command: Codable {
        case subscribe(topics:[Topic])
        case unsubscribe(topics:[Topic])
    }
    enum Report: Decodable {
        case info(Info)
        case subscribe(Subscribe)
        case table(Table)
        case error(Error)
        init(from decoder: Decoder) throws {
            let c = try decoder.container(keyedBy: Field.self)
            if c.contains(.info) {
                self = .info(try Info(from: decoder))
                return
            }
            if c.contains(.subscribe) {
                self = .subscribe(try Subscribe(from: decoder))
                return
            }
            if c.contains(.table) {
                self = .table(try Table(from: decoder))
                return
            }
            if c.contains(.error) {
                self = .error(Issue.bitMEX(.serverError(try c.decode(String.self, forKey: .error))))
            }
            throw Issue.bitMEX(.badFormMessage(message:"Cannot determin message type.", codingPath: decoder.codingPath))
        }
        typealias CodingKeys = Field
        enum Field: String, CodingKey {
            case info, subscribe, error, table
        }
    }
}
